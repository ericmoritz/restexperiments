# use the data and resources from the data collation experiment
from datacollation.app import (control, spouse, children, FrontController,
                               get_data, never_cache, esi_access, GET,
                               ajax_html)
import pylibmc
import memcache
from werkzeug.contrib.cache import SimpleCache
from datetime import datetime
from webob import Request

# Set up the internal caches
simplecache = SimpleCache()
libmc_client = pylibmc.Client(['127.0.0.1'], binary=True)
memcached_client = memcache.Client(['127.0.0.1:11211'])


# A simple expires middleware
def expires(seconds):
    def decor(app):
        def inner(environ, start_response):
            req = Request(environ)
            resp = req.get_response(app)
            resp.cache_expires(seconds)
            resp.date = datetime.utcnow()
            return resp(environ, start_response)
        return inner
    return decor


# Provides enough of 2616 client caching to accomplish the test
# I admit it's a really incomplete HTTP cache proxy :)
def internal_http_cache(app):
    def inner(environ, start_response):
        req = Request(environ)

        # check the simplecache for the current URL
        data = simplecache.get(req.path)

        if data:
            headerlist, body = data
            start_response("200 OK", headerlist)
            return [body]

        resp = req.get_response(app)

        if resp.expires:
            seconds = (resp.date - resp.expires).seconds
            data = (resp.headerlist, resp.body)
            simplecache.set(req.path, data, seconds)

        return resp(environ, start_response)
    return inner


def render(data):
    return "%s;%s" % (data['spouse'],
                      ",".join(data['children']))


def get_cached_data(client):
    spouse = client.get("spouse")
    if spouse is None:
        spouse = get_data()['spouse']
        memcached_client.set("spouse", spouse, 30)

    children = client.get("children")
    if children is None:
        children = get_data()['children']
        memcached_client.set("children", children, 30)

    return {
        'spouse': spouse,
        'children': children
        }


#
# Internal caching cases
# -----------------------
@expires(30)
def mc_app(environ, start_response):
    data = get_cached_data(memcached_client)
    start_response("200 OK", [])
    return render(data)


@expires(30)
def libmc_app(environ, start_response):
    data = get_cached_data(libmc_client)
    start_response("200 OK", [])
    return render(data)

@expires(30)
def simple_app(environ, start_response):
    data = get_cached_data(simplecache)
    start_response("200 OK", [])
    return render(data)

#
# HTTP Caching cases
# ------------------
#
# Set the spouse and children with expirations
spouse = expires(30)(spouse)
children = expires(30)(children)
#
# Internal HTTP Caching
# ----------------------
#
# The middleware app does the same work as the varnish indirect but handles
# the HTTP caching using the internal_http_cache WSGI middleware
mw_spouse = internal_http_cache(spouse)
mw_children = internal_http_cache(children)


@expires(30)
def middleware_app(environ, start_response):
    spouse = GET("http://localhost:8000/mw_spouse")
    children = GET("http://localhost:8000/mw_children")

    start_response("200 OK", [("Content-Type", "text/plain")])
    return ["%s;%s" % (spouse, children)]


#
# Varnish cases
# --------------
#
# Note: never_cache is in place to make sure Varnish does not cache the
# collated response.  We're testing cached data access, which is why the
# spouse and children resources are cached for 30 seconds
#
# There are two Varnish test cases.
#
# Varnish Indirect
# ~~~~~~~~~~~~~~~~~
#
# Varnish indirect mimics the indirect test in the data-collate test but
# pulls the content through Varnish in order to have Varnish handle the
# HTTP caching of the ressources
#
@expires(30)
def varnish_indirect(environ, start_response):
    spouse = GET("http://localhost:10001/spouse")
    children = GET("http://localhost:10001/children")

    start_response("200 OK", [("Content-Type", "text/plain")])
    return ["%s;%s" % (spouse, children)]
#
# The Varnish ESI test case uses the ESI template generated by the esi_access
# WSGI application.  Varnish should cache the responses from the /spouse and
# /children resources because they have the proper expires headers. This is
# assuming that Varnish caching ESI requests
varnish_esi = never_cache(esi_access)

application = FrontController({
        # Resources with the expire headers
        '/spouse': spouse,
        '/children': children,
        '/esi.tmpl': expires(30)(esi_access),

        # The above resources wrapped with the HTTP caching middleware
        '/mw_spouse': mw_spouse,
        '/mw_children': mw_children,

        # The Control
        '/control': control,

        # Internal Data Caching
        '/memcache': mc_app,
        '/libmc': libmc_app,
        '/simple': simple_app,

        # HTTP Caching
        '/middleware': middleware_app,
        '/varnish_indirect': varnish_indirect,
        '/esi': varnish_esi,
}, debug=True)


if __name__ == '__main__':
    from paste.httpserver import serve
    serve(application, host="127.0.0.1",
          port=8000)
