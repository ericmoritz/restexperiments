# use the data and resources from the data collation experiment
from datacollation.app import (control, spouse, children, control,
                               FrontController, get_data, never_cache,
                               indirect_access, esi_access)
import pylibmc
import memcache
from werkzeug.contrib.cache import SimpleCache
from datetime import datetime, timedelta
from webob import Request, Response

# Set up the internal caches
simplecache = SimpleCache()
libmc_client = pylibmc.Client(['127.0.0.1'], binary=True)
memcached_client = memcache.Client(['127.0.0.1:11211'])

# A simple expires middleware
def expires(seconds):
    def decor(app):
        def inner(environ, start_response):
            req = Request(environ)
            resp = req.get_response(app)
            resp.cache_expires(seconds)
            resp.date = datetime.utcnow()
            return resp(environ, start_response)
        return inner
    return decor


# Provides enough of 2616 client caching to accomplish the test
# I admit it's a really incomplete HTTP cache proxy :)
def internal_http_cache(app):
    def inner(environ, start_response):
        req = Request(environ)

        # check the simplecache for the current URL
        data = simplecache.get(req.path)
        
        if data:
            headerlist, body = data
            start_response("200 OK", headerlist)
            return [body]
        
        resp = req.get_response(app)

        if resp.expires:
            seconds = (resp.date - resp.expires).seconds
            data = (resp.headerlist, resp.body)
            simplecache.set(req.path, data, seconds)
        
        return resp(environ, start_response)
    return inner

def render(data):
    return "%s;%s" % (data['spouse'],
                      ",".join(data['children']))

def get_cached_data(client):
    spouse = client.get("spouse")
    if spouse is None:
        spouse = get_data()['spouse']
        memcached_client.set("spouse", spouse, 30)

    children = client.get("children")
    if children is None:
        children = get_data()['children']
        memcached_client.set("children", children, 30)
    
    return {
        'spouse': spouse,
        'children': children
        }

#
# Internal caching cases
# -----------------------
def mc_app(environ, start_response):
    data = get_cached_data(memcached_client)
    start_response("200 OK", [])
    return render(data)

def libmc_app(environ, start_response):
    data = get_cached_data(libmc_client)
    start_response("200 OK", [])
    return render(data)

def simple_app(environ, start_response):
    data = get_cached_data(simplecache)
    start_response("200 OK", [])
    return render(data)

#
# HTTP Caching cases
# ------------------
#
# Set the spouse and children with expirations
spouse = expires(30)(spouse)
children = expires(30)(children)
#
# Internal HTTP Caching
# ----------------------
#
# The middleware app does the same work as the varnish indirect but handles
# the HTTP caching using the internal_http_cache WSGI middleware
middleware_app = internal_http_cache(indirect_access)
#
# Varnish cases
# --------------
#
# These two cases 
# The indirect test has the internal HTTP client caching the resources based
# on the HTTP headers.
# 
# Note: never_cache is in place to make sure Varnish does not cache the 
# collated response.  We're testing cached data access, which is why the 
# spouse and children resources are cached for 30 seconds
#
# This is to be passed through varnish.  The httplib2 client used with the
# indirect_access WSGI application has it's own internal cache
varnish_indirect = never_cache(indirect_access)
#
# The Varnish ESI test case uses the ESI template generated by the esi_access
# WSGI application.  Varnish will cache the responses from the /spouse and
# /children resources because they have the proper expires headers.

def esi_accessx(environ, start_response):
    start_response("200 OK", [("Content-Type", "text/plain")])
    src = ("""<esi:include src="http://localhost:10001/spouse"/>;"""
           """<esi:include src="http://localhost:10001/children"/>""")
    return [src]

varnish_esi = never_cache(esi_access)


application = FrontController({
        # Resources
        '/spouse': spouse,
        '/children': children,

        # The Control
        '/control': control,

        # Internal Data Caching
        '/memcache': mc_app,
        '/libmc': libmc_app,
        '/simple': simple_app,

        # HTTP Caching
        '/middleware': middleware_app,
        '/varnish_indirect': varnish_indirect,
        '/esi': varnish_esi,
}, debug=True)


if __name__ == '__main__':
    from paste.httpserver import serve
    serve(application, host="127.0.0.1",
          port=8000)
